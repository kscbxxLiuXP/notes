# malloc分配内存

## malloc 是如何分配内存的？

`malloc`不是系统调用，是C的库函数，用于动态内存分配，malloc也需要使用系统调用来分配内存

通常有下面两个系统调用来分配内存：

- brk()，在堆中分配内存空间

  brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间

  ![img](http://img.liuxinpeng.cn/brk%E7%94%B3%E8%AF%B7.png)


- mmap()，在文件映射段分配内存

  通过 mmap() 系统调用中`「私有匿名映射」`的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。如下图：

  ![img](http://img.liuxinpeng.cn/mmap%E7%94%B3%E8%AF%B7.png)

  > 什么场景下 malloc() 会通过 brk() 分配内存？又是什么场景下通过 mmap() 分配内存？



`malloc()` 源码里默认定义了一个阈值：

- 如果用户分配的内存小于 `128 KB`，则通过 `brk()` 申请内存；
- 如果用户分配的内存大于 `128 KB`，则通过 `mmap()` 申请内存；

>  注意，不同的 glibc 版本定义的阈值也是不同的。

## malloc 分配的是物理内存吗？

**malloc() 分配的是虚拟内存**。

如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。

只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。

## malloc(1) 会分配多大的内存？

malloc() 在分配内存的时候，并不是老老实实按用户预期申请的字节数来分配内存空间大小，而是**会预分配更大的空间作为内存池**。

**malloc(1) 实际上预分配 132K 字节的内存**。

> 程序里打印的内存起始地址是 `d73010`，而 maps 文件显示堆内存空间的起始地址是 `d73000`，为什么会多出来 `0x10` （16字节）呢？

## free 释放内存，会归还给操作系统吗？

- malloc 通过 **brk()** 方式申请的内存，free 释放内存的时候，**并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用**；

  > 与其把这 1 字节释放给操作系统，不如先缓存着放进 malloc 的内存池里，当进程再次申请 1 字节的内存时就可以直接复用，这样速度快了很多。
  >
  > [解释：存数据，free知道释放多大](#free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？)

- malloc 通过 **mmap()** 方式申请的内存，free 释放内存的时候，**会把内存归还给操作系统，内存得到真正的释放**。

## 为何不全部使用mmap分配内存

向操作系统申请内存需要系统调用，上下文切换开销巨大

mmap等于每次都要系统调用，而且由于mmap释放是真实释放，所以每次访问mmap分配的虚拟地址(第一次访问)，由于没有分配对应的物理空间，必然会`缺页中断`,又是开销巨大

如果使用brk，可以重复利用一段内存空间，减少了系统调用的次数和缺页的次数

## 为何不全部使用brk分配内存

内存泄漏

![图片](http://img.liuxinpeng.cn/75edee0cb75450e7987a8a482b975bda.png)

但是如果下次申请的内存大于 30k，没有可用的空闲内存空间，必须向 OS 申请，实际使用内存继续增大。

因此，随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多不可用的碎片，导致“内存泄露”。而这种“泄露”现象使用 valgrind 是无法检测出来的。

所以，malloc 实现中，充分考虑了 brk 和 mmap 行为上的差异及优缺点，默认分配大块内存 (128KB) 才使用 mmap 分配内存空间。

## free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？



`malloc` 会一开始多分配10个字节用来记录内存的使用情况还有内存的大小

![图片](http://img.liuxinpeng.cn/cb6e3ce4532ff0a6bfd60fe3e52a806e.png)

执行 `free() `函数时，`free` 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了。

# 虚拟内存

本文主要介绍虚拟内存的作用，以及虚拟内存和物理内存之间映射的方式

## 虚拟内存

程序运行时需要在内存中开辟空间，作为多核CPU，肯定不可能同一时间只处理一个应用程序。

此时如果有两个不同的程序要访问同一个内存空间（比如A和B都要访问地址空间`0x123456`），就会发生冲突。

所以为了能够同时运行多个程序，提出了`虚拟内存`的概念，即每个程序都享用完整的内存空间地址(程序视角)，但是实际使用的`物理内存`地址并不是一致的，这个之间的`映射关系`由CPU中的内存管理模块`MMU`负责。

提出这样的概念能够带来很多好处：

- 屏蔽了物理内存的复杂性
- 所有的程序的地址空间都是一样的，不用考虑运行时的状态
- 操作系统能够更好的管理内存，安全性和效率都能够得到提升（可以多个程序同时运行，且不会互相冲突）

![image-20230927094642870](http://img.liuxinpeng.cn/image-20230927094642870.png)

## 内存分段(segmentation)

如果将一个程序全部加载进内存中是不现实的，所以程序会被分为若干段，例如`数据段`,`代码段`,`text段`,`bss段`等。在执行程序时，把用到的段加载进内存，能够很大的节省开销。

在分段的情况下，每一个段内的地址都是基于段首的**偏移地址**

<img src="http://img.liuxinpeng.cn/image-20230927095408004.png" alt="image-20230927095408004" style="zoom:50%;" />

分段下`虚拟内存`是怎么映射到`物理内存`的呢？

> 例如代码段中 偏移地址000234 处的数据
>
> 映射到物理地址，首先要知道段在物理内存的位置，然后加上偏移地址

此时虚拟地址由`段选择因子`和`段内偏移量`组成，通过`段表`查到段的基地址，之后加上段内偏移得到物理地址。

![img](http://img.liuxinpeng.cn/a9ed979e2ed8414f9828767592aadc21.png)

- **段选择子**就保存在段寄存器里面。段选择子里面最重要的是**段号**，用作段表的索引。**段表**里面保存的是这个**段的基地址、段的界限和特权等级**等。
- 虚拟地址中的**段内偏移量**应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

![img](http://img.liuxinpeng.cn/c5e2ab63e6ee4c8db575f3c7c9c85962.png)

存在的问题：

- 内存碎片
- 内存交换效率低(内存交换是为了解决内存碎片)

![img](http://img.liuxinpeng.cn/6142bc3c917e4a6298bdb62936e0d332.png)

上图中就是因为产生了`外部内存碎片`才导致明明内存中有200MB的空间，但是却加载不了应用程序。

> 内存碎片分为`内部碎片`和`外部碎片`
>
> - **内部碎片，是指存储进内存中的数据结构内部存在空隙**。因为分段时，每个段的大小是根据数据容量确定，存入的段是完整的连续的，不存在内部碎片；但是如果分页，每一个页是固定大小，不一定每一个页都会填满，顾会存在内部碎片
> - **外部碎片，是指存储进内存中的若干个数据结构之间存不存在空隙**。对于分段，因为每个段的大小是不确定的，在内存中没有固定的位置，存入存出如果有大小差必然会产生间隙；对于分页，每个页的大小是固定的，可以保证内存中若干页的连续性，所以不存在外部碎片。

外部内存碎片使用`内存交换`解决。简单来说就是把内存中的段写入硬盘中，然后再重新读入内存进行重新排布，将碎片的部分填充掉

> 可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。

这个内存交换空间，在 Linux 系统里，也就是我们常看到的 `Swap` 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。

硬盘的访问的速度比内存慢太多了，分段的方式极容易产生外部碎片，频繁的交换会带来极大的开销，影响效率。如果遇到内存空间很大的程序，整个机器都会卡顿。

## 内存分页(paging)

不同于内存分段，每一个进行的虚拟地址空间进行平均划分，同样的物理内存空间也进行切割划分，这样把**整个虚拟和物理内存空间切成一段段固定尺寸的大小**。这样连续且尺寸固定的内存空间叫`页(Page)`

在Linux下，页的大小划分为`4K`。虚拟地址和物理地址之间通过`页表`来映射

![img](http://img.liuxinpeng.cn/08a8e315fedc4a858060db5cb4a654af.png)

分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是**只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。**

分页模式下，虚拟地址的构成：`页号`+`偏移地址`，**页表**包含物理页每页所在**物理内存的基地址**

![img](http://img.liuxinpeng.cn/7884f4d8db4949f7a5bb4bbd0f452609.png)

总结一下，对于一个内存地址转换，其实就是这样三个步骤：

- 把虚拟内存地址，切分成页号和偏移量；
- 根据页号，从页表里面，查询对应的物理页号；
- 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

![img](http://img.liuxinpeng.cn/8f187878c809414ca2486b0b71e8880e.png)

有空间上的缺陷。

因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。

在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 `4MB` 的内存来存储页表。

这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。

那么，`100` 个进程的话，就需要 `400MB` 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。

### 多级页表

为了解决上面的问题，将虚拟地址分成不同的等级，即`多级页表`。一级页号覆盖全部的内存地址，根据`局部性原理`，并不是所有的地址都会被访问，所以二级页表不着急建立，在访问地址找不到产生`缺页系统终端时`才建立二级页表，并分配物理内存

![img](http://img.liuxinpeng.cn/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png)

如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但**如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表**。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= `0.804MB`，这对比单级页表的 `4MB` 是不是一个巨大的节约？

保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以**页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项**（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。

对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：

- 全局页目录项 PGD（*Page Global Directory*）；
- 上层页目录项 PUD（*Page Upper Directory*）；
- 中间页目录项 PMD（*Page Middle Directory*）；
- 页表项 PTE（*Page Table Entry*）；

![img](http://img.liuxinpeng.cn/%E5%9B%9B%E7%BA%A7%E5%88%86%E9%A1%B5.png)



### TLB

多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。

**把最常访问的几个页表项存储到访问速度更快的硬件**，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 `TLB（Translation Lookaside Buffer）` ，通常称为页表缓存、转址旁路缓存、快表等。

![img](http://img.liuxinpeng.cn/a3cdf27646b24614a64cfc5d7ccffa35-20230927105926699.png)

在 CPU 芯片里面，封装了内存管理单元（*Memory Management Unit*）芯片，它用来完成地址转换和 TLB 的访问与交互。

有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。

TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。

## 段页式内存

![img](http://img.liuxinpeng.cn/f19ebd6f70f84083b0d87cc5e9dea8e3.png)



地址结构就由**段号、段内页号和页内位移**三部分组成。

用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：

![img](http://img.liuxinpeng.cn/8904fb89ae0c49c4b0f2f7b5a0a7b099.png)

段页式地址变换中要得到物理地址须经过三次内存访问：

- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。

可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。

## linux内存布局(与intel处理器历史问题)

**Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理**。于是 Linux 就把所有段的基地址设为 `0`，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。

> intel 在虚拟地址之前还加了一层，使用段表先映射到虚拟地址，然后再用页表映射到物理地址
>
> linux 就把每个段的基地址设为0，这样偏移地址就可以直接当做虚拟地址

### Intel内存管理

80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，**页式内存管理的作用是在由段式内存管理所映射而成的地址上再加上一层地址映射。**

此时由段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为`线性地址`（也称虚拟地址）

假设有一个逻辑地址为0x12345678，首先经过段式内存管理的映射，找到对应的段的基地址为0x80000000，然后加上段内偏移0x345678得到线性地址0x800345678。接着，线性地址再经过页式内存管理的映射，找到对应的物理页框为0xABCDEF00，然后加上页内偏移得到物理地址0xABCDEF78。

### linux内存管理

**Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。**

假设有一个逻辑地址为0x12345678，其中0x12是段号，0x345678是段内偏移。所有段的基地址都被设为0，所以段号对于地址转换没有任何作用，找到对应的段的基地址为0x00000000，然后加上段内偏移0x345678得到线性地址0x345678 ，然后再经过页式内存管理的映射，找到物理页框0xABCDEF00，加上页内偏移0x345678就可以直接计算出物理地址

### linux内存布局

在linux中，内存的布局如下图所示

![img](http://img.liuxinpeng.cn/linux%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)

linux的虚拟内存分为内核空间和用户空间，如果内存大小是4G，那么最上面的1G将会分配给内核空间，这部分空间将会存放操作系统内核程序，拥有最高的权限。剩下的3g用户空间由应用程序分配。

![img](http://img.liuxinpeng.cn/48403193b7354e618bf336892886bcff.png)

在运行多个应用程序时，所有的应用程序共享一个内核空间，最上面的1G内存永远保持在上面，内核虚拟地址保持固定，且虚拟内存和物理内存之间的映射保持一致。这样可以减少陷入内核空间时的系统开销。

每个应用程序独享一个用户空间，用户空间的程序只能访问用户空间的内存地址

用户空间的分配如下：

![虚拟内存空间划分](http://img.liuxinpeng.cn/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)

用户空间内存，从**低到高**分别是 6 种不同的内存段：

- 代码段，包括二进制可执行代码；
- 数据段，包括已初始化的静态常量和全局变量；
- BSS 段，包括未初始化的静态变量和全局变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；
- 文件映射段，包括动态库、共享内存等，从低地址开始向上增长
- 栈段，包括局部变量和函数调用的上下文等，**从高地址向下增长**。栈的大小是固定的，一般是 `8 MB`。当然系统也提供了参数，以便我们自定义大小；

代码段下面还有一段内存空间的（灰色部分），这一块区域是`「保留区」`

> 在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。

在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 `malloc()` 或者 `mmap()` ，就可以分别在堆和文件映射段动态分配内存。


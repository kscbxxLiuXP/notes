# 指针强制转换

> 总结：
>
> 一般不是为了从一个类型转换到另一个类型，而是为了对一个多字节的数据 进行 单字节 的操作
>
> 比如 int* 读取数据时会一次性读取4字节， 如果我只想读取一个字节，那么就需要转化为(char *)读取

假如有这么一个程序

	int a = 0x44332211;
	int *p1 = &a;
	char *p2 = (char *)&a;
	printf("*p1 = 0x%x\n",*p1);
	printf("*p2 = 0x%x\n",*p2);

结果如下图

![在这里插入图片描述](https://www.liuxinpeng.cn/img/202401041522081.png)

分析：
a，p1，p2在内存中的实际效果如下（地址是假设的）

![在这里插入图片描述](https://www.liuxinpeng.cn/img/202401041522961.png)

p1和p2所指向的都是变量a的地址。

**不同的地方在解指针的时候。**

**p1在解指针时，将0x00当作是四个字节的内存空间大小的首地址**。然后以int的解析类型进行解析。也就是说在解指针时会将从0x00为起始的后面总共四个地址所包含的内存空间的数都以int的解析类型解析出来。

**p2在解指针时，将0x00当作是一个字节的内存空间大小的首地址**。然后以char的解析类型进行解析。也就是说在解指针时会将从0x00为起始的后面总共一个地址所包含的内存空间的数都以char的解析类型解析出来。

0x44332211在变量a指向的内存空间中的分布。

![在这里插入图片描述](https://www.liuxinpeng.cn/img/202401041522941.png)

*p1取a中的值时：四个字节作为整体一起解指针

![在这里插入图片描述](https://www.liuxinpeng.cn/img/202401041522617.png)

*p2取a中的值时：对一个字节的空间大小进行解指针

![](https://www.liuxinpeng.cn/img/202401041522360.png)

由于p1和p2的指针类型不同。所以在对p1和p2做+1操作时，效果也会不同。
p1+1后，p1+1指向的内存地址为0x00+4=0x04；
p2+1后，p2+1指向的内存地址为0x00+1=0x01;
